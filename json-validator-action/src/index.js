const core = require('@actions/core');
const github = require('@actions/github');
const { exec } = require('@actions/exec');

async function run() {
  try {
    // Get inputs
    const strictMode = core.getInput('strict-mode') === 'true';
    const errorFormat = core.getInput('error-format');
    
    // Get GitHub context
    const context = github.context;
    const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
    
    core.info('🔍 Starting JSON validation...');
    
    // Find JSON files in the PR
    const jsonFiles = await findJsonFiles();
    
    if (jsonFiles.length === 0) {
      core.info('ℹ️ No JSON files found in this PR');
      await createCheck(octokit, context, 'neutral', 'No JSON files to validate', 'No JSON files were modified in this pull request.');
      return;
    }
    
    core.info(`📁 Found ${jsonFiles.length} JSON file(s): ${jsonFiles.join(', ')}`);
    
    // Run validation
    core.info('🔍 Starting validation process...');
    const validationResult = await validateJsonFiles(jsonFiles);
    core.info(`📊 Validation completed. Has errors: ${validationResult.hasErrors}`);
    
    // Create GitHub check
    if (validationResult.hasErrors) {
      await createCheck(octokit, context, 'failure', 'JSON validation failed', validationResult.output);
      await createPRComment(octokit, context, 'failure', jsonFiles, validationResult.output);
      core.setFailed('JSON validation failed');
    } else {
      await createCheck(octokit, context, 'success', 'JSON validation passed', validationResult.output);
      await createPRComment(octokit, context, 'success', jsonFiles, validationResult.output);
      core.info('✅ All JSON files are valid!');
    }
    
  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

async function findJsonFiles() {
  let output = '';
  let error = '';
  
  const options = {
    listeners: {
      stdout: (data) => {
        output += data.toString();
      },
      stderr: (data) => {
        error += data.toString();
      }
    }
  };
  
  try {
    // Find JSON files changed in the PR
    if (process.env.GITHUB_EVENT_NAME === 'pull_request') {
      await exec('git', ['diff', '--name-only', `origin/${process.env.GITHUB_BASE_REF}...HEAD`], options);
    } else {
      await exec('git', ['diff', '--name-only', 'HEAD~1', 'HEAD'], options);
    }
    
    const allFiles = output.trim().split('\n').filter(file => file.trim());
    const jsonFiles = allFiles.filter(file => file.endsWith('.json'));
    
    return jsonFiles;
  } catch (err) {
    core.warning(`Failed to find JSON files: ${error}`);
    return [];
  }
}

async function validateJsonFiles(jsonFiles) {
  let output = '';
  let error = '';
  let exitCode = 0;
  
  const options = {
    listeners: {
      stdout: (data) => {
        output += data.toString();
      },
      stderr: (data) => {
        error += data.toString();
      }
    }
  };
  
  try {
    const path = require('path');
    const validatorPath = path.join(__dirname, '..', 'validator.js');
    
    core.info(`🚀 Executing validation for files: ${jsonFiles.join(', ')}`);
    core.info(`📁 Using validator at: ${validatorPath}`);
    
    await exec('node', [validatorPath, ...jsonFiles], options);
    core.info('✅ Validation execution completed successfully');
  } catch (err) {
    core.error(`❌ Validation execution failed: ${err.message}`);
    exitCode = err.code || 1;
    output += error;
  }
  
  return {
    hasErrors: exitCode !== 0,
    output: output || error
  };
}


async function createCheck(octokit, context, conclusion, title, output) {
  try {
    await octokit.rest.checks.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      name: 'JSON Validation',
      head_sha: context.sha,
      status: 'completed',
      conclusion: conclusion,
      output: {
        title: title,
        summary: formatCheckSummary(conclusion, output),
        text: formatCheckText(output)
      }
    });
  } catch (error) {
    core.warning(`Failed to create GitHub check: ${error.message}`);
  }
}

function formatCheckSummary(conclusion, output) {
  const lines = output.split('\n');
  const fileCount = (output.match(/✅.*is a valid JSON/g) || []).length;
  const errorCount = (output.match(/❌.*JSON Validation Error/g) || []).length;
  
  if (conclusion === 'success') {
    return `✅ **Validation Passed** - All ${fileCount} JSON file(s) are valid!`;
  } else if (conclusion === 'failure') {
    return `❌ **Validation Failed** - Found ${errorCount} error(s) in JSON file(s)`;
  } else {
    return `ℹ️ **Validation Skipped** - No JSON files were modified`;
  }
}

function formatCheckText(output) {
  return `## JSON Validation Results

\`\`\`
${output}
\`\`\`

---
*Generated by JSON Validator Action*`;
}

async function createPRComment(octokit, context, status, jsonFiles, output) {
  // Only create comments for pull requests
  if (context.eventName !== 'pull_request') {
    return;
  }

  try {
    const commentBody = formatPRComment(status, jsonFiles, output);
    
    await octokit.rest.issues.createComment({
      issue_number: context.issue.number,
      owner: context.repo.owner,
      repo: context.repo.repo,
      body: commentBody
    });
    
    core.info('💬 PR comment created successfully');
  } catch (error) {
    core.warning(`Failed to create PR comment: ${error.message}`);
  }
}

function formatPRComment(status, jsonFiles, output) {
  const fileCount = jsonFiles.length;
  const fileList = jsonFiles.map(file => `- \`${file}\``).join('\n');
  
  if (status === 'success') {
    return `## 🎉 JSON Validation Results

<table>
<tr>
<td align="center">✅</td>
<td><strong>All JSON files are valid!</strong></td>
</tr>
</table>

### 📁 Validated Files (${fileCount})
${fileList}

### 📊 Summary
- **Status**: ✅ **PASSED**
- **Files Checked**: ${fileCount}
- **Errors Found**: 0
- **Issues**: None

<details>
<summary>📋 View Validation Details</summary>

\`\`\`
${output}
\`\`\`

</details>

---
<div align="center">
<sub>🤖 Generated by <a href="https://github.com/your-username/json-validator-action">JSON Validator Action</a></sub>
</div>`;
  } else {
    const errorCount = (output.match(/❌.*JSON Validation Error/g) || []).length;
    const duplicateCount = (output.match(/DuplicateKeyError/g) || []).length;
    const syntaxCount = (output.match(/SyntaxError/g) || []).length;
    const htmlCount = (output.match(/InvalidHTMLError/g) || []).length;
    
    return `## ❌ JSON Validation Results

<table>
<tr>
<td align="center">❌</td>
<td><strong>JSON validation failed!</strong></td>
</tr>
</table>

### 📁 Files Checked (${fileCount})
${fileList}

### 📊 Summary
- **Status**: ❌ **FAILED**
- **Files Checked**: ${fileCount}
- **Total Errors**: ${errorCount}
- **Duplicate Keys**: ${duplicateCount}
- **Syntax Errors**: ${syntaxCount}
- **Invalid HTML**: ${htmlCount}

### 🚨 Issues Found
${formatErrorSummary(output)}

<details>
<summary>📋 View Full Error Details</summary>

\`\`\`
${output}
\`\`\`

</details>

### 💡 Next Steps
1. **Review the errors** in the details above
2. **Fix the issues** in your JSON files
3. **Push your changes** to update this PR
4. **Validation will run again** automatically

---
<div align="center">
<sub>🤖 Generated by <a href="https://github.com/your-username/json-validator-action">JSON Validator Action</a></sub>
</div>`;
  }
}

function formatErrorSummary(output) {
  const lines = output.split('\n');
  const errors = [];
  let currentError = null;
  
  for (const line of lines) {
    if (line.includes('❌ JSON Validation Error')) {
      if (currentError) {
        errors.push(currentError);
      }
      const match = line.match(/in (.*?):/);
      currentError = {
        file: match ? match[1] : 'Unknown file',
        type: '',
        message: '',
        line: ''
      };
    } else if (currentError && line.includes('Error Type:')) {
      currentError.type = line.split('Error Type:')[1].trim();
    } else if (currentError && line.includes('Error Message:')) {
      currentError.message = line.split('Error Message:')[1].trim();
    } else if (currentError && line.includes('Line:')) {
      currentError.line = line.split('Line:')[1].trim();
    }
  }
  
  if (currentError) {
    errors.push(currentError);
  }
  
  return errors.map(error => {
    let icon = '⚠️';
    if (error.type === 'DuplicateKeyError') {
      icon = '🔑';
    } else if (error.type === 'InvalidHTMLError') {
      icon = '🏷️';
    }
    return `- ${icon} **${error.file}** (Line ${error.line}) - ${error.type}`;
  }).join('\n');
}

// Run the action
run();
